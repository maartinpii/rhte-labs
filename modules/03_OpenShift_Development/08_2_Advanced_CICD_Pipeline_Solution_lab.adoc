:scrollbar:
:noaudio:
:data-uri:
:imagesdir: images
:toc2:


== Advanced CI/CD Pipeline Lab Solutions

:numbered:

== Prepare to Store Build Artifacts in Nexus

In this section, you create a `openshift-tasks-ocp` repository in Gogs under the `CICDLabs` organization.

. On your workstation create the files for the repository:
+
[source,bash]
----
mkdir -p $HOME/openshift-tasks-ocp/.s2i/bin
cd $HOME/openshift-tasks-ocp
curl -o .s2i/environment https://raw.githubusercontent.com/wkulhanek/ocp_advanced_development_resources/master/s2i/environment
curl -o .s2i/bin/assemble https://raw.githubusercontent.com/wkulhanek/ocp_advanced_development_resources/master/s2i/assemble
chmod +x .s2i/bin/assemble
----
+
[NOTE]
This assemble script is called later when you run the S2I builder process to deploy the `openshift-tasks` application. Instead of building the application from scratch, this script simply retrieves the location of the WAR file that you built in Jenkins and deploys it onto the JBoss EAP server. The environment script is empty when you first commit to Gogs. It is populated upon successful completion of the Jenkins pipeline.

. Push the completed repository to Gogs, making sure to replace `<gogs_user>` and `<gogs_password>` with your actual credentials:
+
[source,bash]
----
git init
git remote add gogs http://<gogs_user>:<gogs_password>@$(oc get route gogs -n xyz-gogs --template='{{ .spec.host }}')/CICDLabs/openshift-tasks-ocp.git
git add --all
git commit -m "initial commit"
git push gogs master
----

== Set Up Development and Production Projects in OpenShift

. Create the OpenShift project to hold the development version of the `openshift-tasks` application. Make sure that automatic building is turned off. Finally, tag the built image as `TestingCandidate-1.0` and `ProdReady-1.0`:
+
[source,bash]
----
oc new-project xyz-tasks-dev --display-name "Tasks Development"
oc new-app eap64-basic-s2i --param APPLICATION_NAME=tasks --param SOURCE_REPOSITORY_URL=http://gogs.xyz-gogs.svc.cluster.local:3000/CICDLabs/openshift-tasks-ocp.git --param SOURCE_REPOSITORY_REF=master --param CONTEXT_DIR=/
oc set triggers dc/tasks --remove-all
----

. Wait for the build to complete before continuing.
+
[source,bash]
----
oc tag tasks:latest tasks:TestingCandidate-1.0
oc tag tasks:TestingCandidate-1.0 tasks:ProdReady-1.0
oc policy add-role-to-group admin system:serviceaccounts:xyz-jenkins -n xyz-tasks-dev
----

. Create the OpenShift project to hold the production version of the `openshift-tasks` application and set up for Blue/Green deployment by deploying two versions of the application (`tasks-green` and `tasks-blue`), initially exposing the `tasks-green` service as the `tasks` route:
+
[source,bash]
----
oc new-project xyz-tasks-prod --display-name "Tasks Production"
oc policy add-role-to-group system:image-puller system:serviceaccounts:xyz-tasks-prod -n xyz-tasks-dev
oc policy add-role-to-group admin system:serviceaccounts:wk-jenkins -n xyz-tasks-prod
oc new-app xyz-tasks-dev/tasks:ProdReady-1.0 --name=tasks-green
oc new-app xyz-tasks-dev/tasks:ProdReady-1.0 --name=tasks-blue
oc set triggers dc/tasks-green --remove-all
oc set triggers dc/tasks-blue --remove-all
oc expose svc/tasks-green --name tasks
----
+
[IMPORTANT]
While the initial build completes, it creates an unusable image. This happens because you have not run a build in Jenkins yet, so there is no WAR file to retrieve from Nexus. This issue resolves itself once the pipeline is executed.

== Build Pipeline

In this section, you create a Jenkins pipeline to perform the following steps:

* Checkout source code
* Build WAR
* Run unit tests
* Perform code analysis
* Publish to Nexus
* Build OpenShift image
* Deploy to test
* Run integration tests
* Deploy the new version to production (Blue/Green)
* Get approval to switch to the new version
* Switch to the new route

The following steps describe how to build the Jenkins pipeline:

. In Jenkins, create a job with the name `Tasks` and type `Pipeline`.

. Use this Groovy pipeline script, either inline in the Jenkins job, or by storing it in the `openshift-tasks` Gogs repository and pointing the Jenkins job to it. Depending on the approach make sure to use the correct version of the `Checkout Source` stage. Make sure you double-check references to SkyDNS services and replace `<gogs_user>` and `<gogs_password>` with your Gogs user ID and password where necessary.
+
[source,groovy]
----
#!groovy

// Run this node on a Maven Slave
// Maven Slaves have JDK and Maven already installed
node('maven') {
  // Make sure your nexus_openshift_settings.xml
  // Is pointing to your nexus instance
  def mvnCmd = "mvn -s ./nexus_openshift_settings.xml"

  stage('Checkout Source') {
    // Get Source Code from SCM (Git) as configured in the Jenkins Project
    // Next line for inline script, "checkout scm" for Jenkinsfile from Gogs
    //git 'http://gogs.xyz-gogs.svc.cluster.local:3000/CICDLabs/openshift-tasks.git'
    checkout scm
  }

  // The following variables need to be defined at the top level and not inside
  // the scope of a stage - otherwise they would not be accessible from other stages.
  // Extract version and other properties from the pom.xml
  def groupId    = getGroupIdFromPom("pom.xml")
  def artifactId = getArtifactIdFromPom("pom.xml")
  def version    = getVersionFromPom("pom.xml")

  stage('Build war') {
    echo "Building version ${version}"

    sh "${mvnCmd} clean package -DskipTests"
  }
  stage('Unit Tests') {
    echo "Unit Tests"
    sh "${mvnCmd} test"
  }
  stage('Code Analysis') {
    echo "Code Analysis"

    // Replace xyz-sonarqube with the name of your project
    sh "${mvnCmd} sonar:sonar -Dsonar.host.url=http://sonarqube.xyz-sonarqube.svc.cluster.local:9000/ -Dsonar.projectName=${JOB_BASE_NAME}"
  }
  stage('Publish to Nexus') {
    echo "Publish to Nexus"

    // Replace xyz-nexus with the name of your project
    sh "${mvnCmd} deploy -DskipTests=true -DaltDeploymentRepository=nexus::default::http://nexus3.xyz-nexus.svc.cluster.local:8081/repository/releases"
    // Get Repository from Git/Gogs
    // Replace xyz-gogs with the name of your Gogs project
    git url: 'http://<gogs_user>:<gogs_password>@gogs.xyz-gogs.svc.cluster.local:3000/CICDLabs/openshift-tasks-ocp.git'

    // Create war file name from pom.xml properties
    String warFileName = "${groupId}.${artifactId}"
    warFileName = warFileName.replace('.', '/')
    sh "echo ${warFileName}/${version}/${artifactId}-${version}.war"

    // Update the .s2i/environment file with the location of the latest war file name
    // Also add Build Number so that every build we get a unique environment file and
    // The git commit/push step succeeds.
    // Replace xyz-nexus with the name of your project
    sh "echo WAR_FILE_LOCATION=http://nexus3.xyz-nexus.svc.cluster.local:8081/repository/releases/${warFileName}/${version}/${artifactId}-${version}.war >.s2i/environment"
    sh "echo BUILD_NUMBER=${BUILD_NUMBER} >>.s2i/environment"

    // Update the Git/Gogs repository with the latest file
    // Replace XYZ with your Initials
    def commit = "Release " + version
    sh "git config --global user.email xyz@example.opentlc.com && git config --global user.name XYZJenkins"
    sh "git add .s2i/environment && git commit -m \"${commit}\" && git push origin master"
  }

  stage('Build OpenShift Image') {
    def newTag = "TestingCandidate-${version}"
    echo "New Tag: ${newTag}"

    // Replace xyz-tasks-dev with the name of your dev project
    openshiftBuild bldCfg: 'tasks', checkForTriggeredDeployments: 'false', namespace: 'xyz-tasks-dev', showBuildLogs: 'false', verbose: 'false', waitTime: '', waitUnit: 'sec'
    openshiftVerifyBuild bldCfg: 'tasks', checkForTriggeredDeployments: 'false', namespace: 'xyz-tasks-dev', verbose: 'false', waitTime: ''
    openshiftTag alias: 'false', destStream: 'tasks', destTag: newTag, destinationNamespace: 'xyz-tasks-dev', namespace: 'xyz-tasks-dev', srcStream: 'tasks', srcTag: 'latest', verbose: 'false'
  }

  stage('Deploy to Dev') {
    // Patch the DeploymentConfig so that it points to the latest TestingCandidate-${version} Image.
    // Replace xyz-tasks-dev with the name of your dev project
    sh "oc project xyz-tasks-dev"
    sh "oc patch dc tasks --patch '{\"spec\": { \"triggers\": [ { \"type\": \"ImageChange\", \"imageChangeParams\": { \"containerNames\": [ \"tasks\" ], \"from\": { \"kind\": \"ImageStreamTag\", \"namespace\": \"xyz-tasks-dev\", \"name\": \"tasks:TestingCandidate-$version\"}}}]}}' -n xyz-tasks-dev"

    openshiftDeploy depCfg: 'tasks', namespace: 'xyz-tasks-dev', verbose: 'false', waitTime: '', waitUnit: 'sec'
    openshiftVerifyDeployment depCfg: 'tasks', namespace: 'xyz-tasks-dev', replicaCount: '1', verbose: 'false', verifyReplicaCount: 'false', waitTime: '', waitUnit: 'sec'
    openshiftVerifyService namespace: 'xyz-tasks-dev', svcName: 'tasks', verbose: 'false'
  }

  stage('Integration Test') {
    // TBD: Proper test
    // Could use the OpenShift-Tasks REST APIs to make sure it is working as expected.

    def newTag = "ProdReady-${version}"
    echo "New Tag: ${newTag}"

    // Replace xyz-tasks-dev with the name of your dev project
    openshiftTag alias: 'false', destStream: 'tasks', destTag: newTag, destinationNamespace: 'xyz-tasks-dev', namespace: 'xyz-tasks-dev', srcStream: 'tasks', srcTag: 'latest', verbose: 'false'
  }

  // Blue/Green Deployment into Production
  // -------------------------------------
  def dest   = "tasks-green"
  def active = ""

  stage('Prep Production Deployment') {
    // Replace xyz-tasks-dev and xyz-tasks-prod with
    // your project names
    sh "oc project xyz-tasks-prod"
    sh "oc get route tasks -n xyz-tasks-prod -o jsonpath='{ .spec.to.name }' > activesvc.txt"
    active = readFile('activesvc.txt').trim()
    if (active == "tasks-green") {
      dest = "tasks-blue"
    }
    echo "Active svc: " + active
    echo "Dest svc:   " + dest
  }
  stage('Deploy new Version') {
    echo "Deploying to ${dest}"

    // Patch the DeploymentConfig so that it points to
    // the latest ProdReady-${version} Image.
    // Replace xyz-tasks-dev and xyz-tasks-prod with
    // your project names.
    sh "oc patch dc ${dest} --patch '{\"spec\": { \"triggers\": [ { \"type\": \"ImageChange\", \"imageChangeParams\": { \"containerNames\": [ \"$dest\" ], \"from\": { \"kind\": \"ImageStreamTag\", \"namespace\": \"xyz-tasks-dev\", \"name\": \"tasks:ProdReady-$version\"}}}]}}' -n xyz-tasks-prod"

    openshiftDeploy depCfg: dest, namespace: 'xyz-tasks-prod', verbose: 'false', waitTime: '', waitUnit: 'sec'
    openshiftVerifyDeployment depCfg: dest, namespace: 'xyz-tasks-prod', replicaCount: '1', verbose: 'false', verifyReplicaCount: 'true', waitTime: '', waitUnit: 'sec'
    openshiftVerifyService namespace: 'xyz-tasks-prod', svcName: dest, verbose: 'false'
  }
  stage('Switch over to new Version') {
    input "Switch Production?"

    // Replace xyz-tasks-prod with the name of your
    // production project
    sh 'oc patch route tasks -n xyz-tasks-prod -p \'{"spec":{"to":{"name":"' + dest + '"}}}\''
    sh 'oc get route tasks -n xyz-tasks-prod > oc_out.txt'
    oc_out = readFile('oc_out.txt')
    echo "Current route configuration: " + oc_out
  }
}

// Convenience Functions to read variables from the pom.xml
def getVersionFromPom(pom) {
  def matcher = readFile(pom) =~ '<version>(.+)</version>'
  matcher ? matcher[0][1] : null
}
def getGroupIdFromPom(pom) {
  def matcher = readFile(pom) =~ '<groupId>(.+)</groupId>'
  matcher ? matcher[0][1] : null
}
def getArtifactIdFromPom(pom) {
  def matcher = readFile(pom) =~ '<artifactId>(.+)</artifactId>'
  matcher ? matcher[0][1] : null
}
----

== Set Up Web Deployment Hook

To automate the build whenever new content is pushed to the `openshift-tasks` repository, set up a Git hook in Gogs. This way a Jenkins build is triggered whenever code is pushed to the `openshift-tasks` source repository on Gogs.

. Open a browser and log in to Jenkins.

. In the top right corner, click the down arrow next to your user name and select *Configure*.

. Click *Show API Token* and make note of the API token that is displayed.

. Open a browser, navigate to the Gogs server, log in, and go to the `CICDLabs/openshift-tasks` repository.

. Click *Settings*, and then click *Git Hooks*.

. Click the pencil next to *post-receive*.

. Under the *Hook Content*, paste this script, replacing `<userid>` with your Jenkins user ID, `<apiToken>` with the API token you retrieved earlier, `<jenkinsService>` with the name of your Jenkins Service and `<jenkinsProject>` with the name of the OpenShift project your Jenkins Service is located in:
+
[source,bash]
----
#!/bin/bash

while read oldrev newrev refname
do
    branch=$(git rev-parse --symbolic --abbrev-ref $refname)
    if [[ "$branch" == "master" ]]; then
    	curl -k -X POST --user <userid>:<apiToken> http://<jenkinsService>.<jenkinsProject>.svc.cluster.local/job/Tasks/build
    fi
done
----
+
* This script signals the Jenkins `Tasks` build job each time a commit is made to the master branch.

. Click *Update Hook*.

== Trigger New Build

Committing a new version of the application source code triggers a new build as a result of the Git hook you configured. It is good practice to increment the version number each time you make changes to your application. You can increment the version number manually or automatically.

. Increment the version number:

* Change the `openshift-tasks` source code to make sure you are seeing an updated version of your application after the pipeline completes.
** Look near line 45 of the code--where the title of the page is rendered--in the `$HOME/openshift-tasks/src/main/webapp/index.js` file.

* Increment the version number of the project each time code is pushed using Maven--for example, updating the version number (`VERSION=1.2`) with the next minor or major number (`VERSION=1.3`):
+
[source,bash]
----
cd $HOME/openshift-tasks
export VERSION=1.3
mvn versions:set -f pom.xml -s nexus_settings.xml -DgenerateBackupPoms=false -DnewVersion=${VERSION}
git commit -m "Increased version to ${VERSION}" pom.xml
git push gogs master
----

. After a few minutes, when prompted, approve the switch to the new version.

. Click *Proceed*.

. Once the pipeline finishes successfully, verify that you can see the updated application.

== Build Configuration with Pipeline

To integrate the pipeline with the OpenShift web console, you create a build configuration that points to this pipeline. This build configuration must be in the same project as the Jenkins pod (unless you configure the `master-config.yaml` to point to another Jenkins instance).

. Create the `tasks-pipeline.yaml` file:
+
[source,yaml]
----
apiVersion: v1
items:
- kind: "BuildConfig"
  apiVersion: "v1"
  metadata:
    name: "tasks-pipeline"
  spec:
    source:
      type: "Git"
      git:
        uri: "http://gogs.xyz-gogs.svc.cluster.local:3000/CICDLabs/openshift-tasks"
    strategy:
      type: "JenkinsPipeline"
      jenkinsPipelineStrategy:
        jenkinsfilePath: Jenkinsfile
kind: List
metadata: []
----
+
[NOTE]
You are pointing to the Jenkinsfile in the Gogs repository, as you did in the Jenkins `Tasks` job. It is also possible to embed the entire pipeline script into the build configuration.

. Create the build configuration in OpenShift:
+
[source,bash]
----
oc project xyz-jenkins
oc create -f tasks-pipeline.yaml
----

. In the OpenShift web console, switch to your Jenkins project and open the *Pipelines* view (under *Builds*).

. Click *Start Pipeline* to trigger a new pipeline.

. Click *View Log* to view the pipeline progression and follow along in Jenkins.
